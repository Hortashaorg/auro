---
description: How to propery build UI
globs: 
alwaysApply: false
---
# UI Building Guidelines

Follow these principles when developing UI components and features to ensure consistency, maintainability, and reusability.

## 1. Leverage Atomic Design Components

- Prioritize Atoms & Molecules: When constructing UI elements or features, primarily use the existing Atoms and Molecules defined in `services/app/components/atoms/` and `services/app/components/molecules/`. Refer to the `components.mdc` rule for an overview.
- Avoid Style Overrides: Refrain from overriding the default styles of existing Atom and Molecule components (e.g., using inline styles or overly specific CSS selectors). Their predefined styles ensure visual consistency.
- Extend or Create, Don't Hack: If the existing components don't meet the required functionality or visual appearance:
    - Consider if an existing component can be *extended* with new variants or props to support the use case.
    - If extension isn't feasible, create a *new* reusable Atom or Molecule following the established patterns.
    - Avoid creating one-off styles or complex local component structures for things that should be part of the core component library.


## 2. Structure for Route-Specific Dynamic Content (HTMX)

- **Co-locate within Routes:** When building UI fragments designed for HTMX interactions (swapping, partial updates) that are specific to a particular route (e.g., editing profile nicknames), place both the component rendering the fragment (using the `.section.tsx` suffix, e.g., `EditNicknamesForm.section.tsx`) and the API endpoint handling the HTMX request (using the `.api.tsx` suffix, e.g., `UpdateNicknames.api.tsx`) directly within that route's directory in `services/app/routes/`.
- **Follow Route Structure:** Adhere to the organization outlined in [repo_structure.mdc](mdc:.cursor/rules/repo_structure.mdc). For instance, profile-related sections and APIs belong in `services/app/routes/profile/`.
- **Use Naming Conventions:** Employ noun-first naming for section components (e.g., `ProfileDetails.section.tsx`) and verb-first naming for API endpoints (e.g., `UpdateProfile.api.tsx`), as shown in `repo_structure.mdc`.
- **Page Routes:** Full page components continue to use the `{RouteName}.page.tsx` convention within the route directory.

## 3. Handling Local UI State Changes (Edit Toggles, etc.)

-   **Use Alpine.js for Local State:** For interactions that only change the UI state *within* a loaded section or component (e.g., toggling between a display view and an edit form, showing/hiding details) **without needing new data from the server**, use Alpine.js (`x-data`, `x-show`, `x-if`, `x-on:click`, etc.).
-   **Avoid HTMX for Pure UI Toggles:** Do **not** use HTMX GET requests (`hx-get`) solely to fetch slightly different view fragments (like switching to an edit form) if the necessary data is already available on the client. This creates unnecessary server load and network latency.
-   **HTMX for Server Actions:** Reserve HTMX (`hx-post`, `hx-put`, `hx-delete`) primarily for actions that require **server interaction** (e.g., submitting form data to update the database, deleting an item).
-   **Example Pattern (Inline Edit):**
    1.  Load the section (`.section.tsx`) containing both display and form elements.
    2.  Use `x-data` to hold an `isEditing` flag.
    3.  Use `x-show` or `x-if` to conditionally display either the view elements or the form elements based on `isEditing`.
    4.  An "Edit" button sets `isEditing = true` via `x-on:click`.
    5.  A "Cancel" button sets `isEditing = false` via `x-on:click`.
    6.  The "Save" button within the form uses `hx-post` to submit data to the appropriate API endpoint. The API response should ideally replace the section (`hx-swap="outerHTML"`) with the updated view, naturally resetting the Alpine state.


### Goal
This co-location strategy keeps all code related to a specific route feature together, improving discoverability and maintainability.